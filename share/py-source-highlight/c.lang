# autogenerated from pygments for C
# if0 state
state Token_Comment_Preproc = '^#if\s+0' begin
  # nested if0 state
  state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
    Token_Comment start '.*?'
  end
  Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
  Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
  Token_Comment start '.*?'
end
# macro state
state Token_Comment_Preproc = '^#' begin
  (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
  Token_Comment_Preproc = '[^/\n]+'
  Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
  Token_Comment_Single start '//.*?' exit
  Token_Comment_Preproc = '/'
  Token_Comment_Preproc start '(?<=\\)'
  Token_Comment_Preproc = '$' exit
end
# if0 state
state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#if\s+0)` begin
  # nested if0 state
  state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
    Token_Comment start '.*?'
  end
  Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
  Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
  Token_Comment start '.*?'
end
# macro state
state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#)` begin
  (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
  Token_Comment_Preproc = '[^/\n]+'
  Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
  Token_Comment_Single start '//.*?' exit
  Token_Comment_Preproc = '/'
  Token_Comment_Preproc start '(?<=\\)'
  Token_Comment_Preproc = '$' exit
end
Token_Text = '\s+'
Token_Text start '\\'
Token_Comment_Single = '//(\n|[\w\W]*?[^\\]\n)'
Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*?[*](\\\n)?/'
Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*'
# function state
state (Token_Operator,Token_Name_Function,Token_Punctuation,Token_Text,Token_Punctuation) = `((?:[\w*\s])+?(?:\s|[*]))([a-zA-Z_]\w*)(\s*\([^;]*?\))([^;{]*)(\{)` begin
  # if0 state
  state Token_Comment_Preproc = '^#if\s+0' begin
    # nested if0 state
    state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
      Token_Comment start '.*?'
    end
    Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
    Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
    Token_Comment start '.*?'
  end
  # macro state
  state Token_Comment_Preproc = '^#' begin
    (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
    Token_Comment_Preproc = '[^/\n]+'
    Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
    Token_Comment_Single start '//.*?' exit
    Token_Comment_Preproc = '/'
    Token_Comment_Preproc start '(?<=\\)'
    Token_Comment_Preproc = '$' exit
  end
  # if0 state
  state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#if\s+0)` begin
    # nested if0 state
    state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
      Token_Comment start '.*?'
    end
    Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
    Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
    Token_Comment start '.*?'
  end
  # macro state
  state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#)` begin
    (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
    Token_Comment_Preproc = '[^/\n]+'
    Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
    Token_Comment_Single start '//.*?' exit
    Token_Comment_Preproc = '/'
    Token_Comment_Preproc start '(?<=\\)'
    Token_Comment_Preproc = '$' exit
  end
  Token_Text = '\s+'
  Token_Text start '\\'
  Token_Comment_Single = '//(\n|[\w\W]*?[^\\]\n)'
  Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*?[*](\\\n)?/'
  Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*'
  # string state
  state (Token_Literal_String_Affix,Token_Literal_String) = `(L?)(")` begin
    Token_Literal_String = '"' exit
    Token_Literal_String_Escape = '\\([\\abfnrtv"\']|x[a-fA-F0-9]{2,4}|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8}|[0-7]{1,3})'
    Token_Literal_String = '[^\\"\n]+'
    Token_Literal_String start '\\'
    Token_Literal_String = '\\'
  end
  (Token_Literal_String_Affix,Token_Literal_String_Char,Token_Literal_String_Char,Token_Literal_String_Char) = `(L?)(')(\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])(')`
  Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*'
  Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+[fF])[fF]?'
  Token_Literal_Number_Hex = '0x[0-9a-fA-F]+[LlUu]*'
  Token_Literal_Number_Oct = '0[0-7]+[LlUu]*'
  Token_Literal_Number_Integer = '\d+[LlUu]*'
  Token_Error = '\*/'
  Token_Operator = '[~!%^&*+=|?:<>/-]'
  Token_Punctuation = '[()\[\],.]'
  Token_Keyword = '(a(?:sm|uto)|break|c(?:ase|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtern)|for|goto|if|re(?:gister|stricted|turn)|s(?:izeof|t(?:atic|ruct)|witch)|typedef|union|(?:volat|wh)ile)\b'
  Token_Keyword_Type = '(bool|int|long|float|short|double|char|unsigned|signed|void)\b'
  Token_Keyword_Reserved = '(_(?:(?:(?:_)?)inline)|inline|naked|restrict|t(?:hread|ypename))\b'
  Token_Keyword_Reserved = '(__m(128i|128d|128|64))\b'
  Token_Keyword_Reserved = '__(as(?:m|sume)|based|cdecl|declspec|except|f(?:astcall|inally|orceinline)|i(?:dentifier|nt(?:16|32|64|8))|leave|noop|raise|stdcall|try|unaligned|w(?:64|char_t))\b'
  Token_Name_Builtin = '(true|false|NULL)\b'
  (Token_Name_Label,Token_Text,Token_Punctuation) = `([a-zA-Z_]\w*)(\s*)(:)[^:]`
  Token_Name = '[a-zA-Z_]\w*'
  Token_Punctuation = ';'
  # nested function state
  state Token_Punctuation delim '\{' '\}' nested begin
    # if0 state
    state Token_Comment_Preproc = '^#if\s+0' begin
      # nested if0 state
      state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
        Token_Comment start '.*?'
      end
      Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
      Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
      Token_Comment start '.*?'
    end
    # macro state
    state Token_Comment_Preproc = '^#' begin
      (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
      Token_Comment_Preproc = '[^/\n]+'
      Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
      Token_Comment_Single start '//.*?' exit
      Token_Comment_Preproc = '/'
      Token_Comment_Preproc start '(?<=\\)'
      Token_Comment_Preproc = '$' exit
    end
    # if0 state
    state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#if\s+0)` begin
      # nested if0 state
      state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
        Token_Comment start '.*?'
      end
      Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
      Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
      Token_Comment start '.*?'
    end
    # macro state
    state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#)` begin
      (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
      Token_Comment_Preproc = '[^/\n]+'
      Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
      Token_Comment_Single start '//.*?' exit
      Token_Comment_Preproc = '/'
      Token_Comment_Preproc start '(?<=\\)'
      Token_Comment_Preproc = '$' exit
    end
    Token_Text = '\s+'
    Token_Text start '\\'
    Token_Comment_Single = '//(\n|[\w\W]*?[^\\]\n)'
    Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*?[*](\\\n)?/'
    Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*'
    # string state
    state (Token_Literal_String_Affix,Token_Literal_String) = `(L?)(")` begin
      Token_Literal_String = '"' exit
      Token_Literal_String_Escape = '\\([\\abfnrtv"\']|x[a-fA-F0-9]{2,4}|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8}|[0-7]{1,3})'
      Token_Literal_String = '[^\\"\n]+'
      Token_Literal_String start '\\'
      Token_Literal_String = '\\'
    end
    (Token_Literal_String_Affix,Token_Literal_String_Char,Token_Literal_String_Char,Token_Literal_String_Char) = `(L?)(')(\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])(')`
    Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*'
    Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+[fF])[fF]?'
    Token_Literal_Number_Hex = '0x[0-9a-fA-F]+[LlUu]*'
    Token_Literal_Number_Oct = '0[0-7]+[LlUu]*'
    Token_Literal_Number_Integer = '\d+[LlUu]*'
    Token_Error = '\*/'
    Token_Operator = '[~!%^&*+=|?:<>/-]'
    Token_Punctuation = '[()\[\],.]'
    Token_Keyword = '(a(?:sm|uto)|break|c(?:ase|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtern)|for|goto|if|re(?:gister|stricted|turn)|s(?:izeof|t(?:atic|ruct)|witch)|typedef|union|(?:volat|wh)ile)\b'
    Token_Keyword_Type = '(bool|int|long|float|short|double|char|unsigned|signed|void)\b'
    Token_Keyword_Reserved = '(_(?:(?:(?:_)?)inline)|inline|naked|restrict|t(?:hread|ypename))\b'
    Token_Keyword_Reserved = '(__m(128i|128d|128|64))\b'
    Token_Keyword_Reserved = '__(as(?:m|sume)|based|cdecl|declspec|except|f(?:astcall|inally|orceinline)|i(?:dentifier|nt(?:16|32|64|8))|leave|noop|raise|stdcall|try|unaligned|w(?:64|char_t))\b'
    Token_Name_Builtin = '(true|false|NULL)\b'
    (Token_Name_Label,Token_Text,Token_Punctuation) = `([a-zA-Z_]\w*)(\s*)(:)[^:]`
    Token_Name = '[a-zA-Z_]\w*'
    Token_Punctuation = ';'
  end
  Token_Punctuation = '\}' exit
end
(Token_Operator,Token_Name_Function,Token_Punctuation,Token_Text,Token_Punctuation) = `((?:[\w*\s])+?(?:\s|[*]))([a-zA-Z_]\w*)(\s*\([^;]*?\))([^;]*)(;)`
# statement state
state Token_Text = '' begin
  # if0 state
  state Token_Comment_Preproc = '^#if\s+0' begin
    # nested if0 state
    state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
      Token_Comment start '.*?'
    end
    Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
    Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
    Token_Comment start '.*?'
  end
  # macro state
  state Token_Comment_Preproc = '^#' begin
    (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
    Token_Comment_Preproc = '[^/\n]+'
    Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
    Token_Comment_Single start '//.*?' exit
    Token_Comment_Preproc = '/'
    Token_Comment_Preproc start '(?<=\\)'
    Token_Comment_Preproc = '$' exit
  end
  # if0 state
  state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#if\s+0)` begin
    # nested if0 state
    state Token_Comment_Preproc delim '^\s*#if.*?(?<!\\)\n' '(\s*#el(?:se|if).*\n)|(\s*#endif.*?(?<!\\)\n)' nested begin
      Token_Comment start '.*?'
    end
    Token_Comment_Preproc start '^\s*#el(?:se|if)' exit
    Token_Comment_Preproc start '^\s*#endif.*?(?<!\\)' exit
    Token_Comment start '.*?'
  end
  # macro state
  state (Token_Comment_Multiline,Token_Comment_Preproc) = `(\s*(?:/[*].*?[*]/\s*)?)(#)` begin
    (Token_Comment_Preproc,Token_Text,Token_Comment_PreprocFile) = `(include)(\s*(?:/[*].*?[*]/\s*)?)([^\n]+)`
    Token_Comment_Preproc = '[^/\n]+'
    Token_Comment_Multiline = '/[*](.|\n)*?[*]/'
    Token_Comment_Single start '//.*?' exit
    Token_Comment_Preproc = '/'
    Token_Comment_Preproc start '(?<=\\)'
    Token_Comment_Preproc = '$' exit
  end
  Token_Text = '\s+'
  Token_Text start '\\'
  Token_Comment_Single = '//(\n|[\w\W]*?[^\\]\n)'
  Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*?[*](\\\n)?/'
  Token_Comment_Multiline = '/(\\\n)?[*][\w\W]*'
  # string state
  state (Token_Literal_String_Affix,Token_Literal_String) = `(L?)(")` begin
    Token_Literal_String = '"' exit
    Token_Literal_String_Escape = '\\([\\abfnrtv"\']|x[a-fA-F0-9]{2,4}|u[a-fA-F0-9]{4}|U[a-fA-F0-9]{8}|[0-7]{1,3})'
    Token_Literal_String = '[^\\"\n]+'
    Token_Literal_String start '\\'
    Token_Literal_String = '\\'
  end
  (Token_Literal_String_Affix,Token_Literal_String_Char,Token_Literal_String_Char,Token_Literal_String_Char) = `(L?)(')(\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])(')`
  Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+)[eE][+-]?\d+[LlUu]*'
  Token_Literal_Number_Float = '(\d+\.\d*|\.\d+|\d+[fF])[fF]?'
  Token_Literal_Number_Hex = '0x[0-9a-fA-F]+[LlUu]*'
  Token_Literal_Number_Oct = '0[0-7]+[LlUu]*'
  Token_Literal_Number_Integer = '\d+[LlUu]*'
  Token_Error = '\*/'
  Token_Operator = '[~!%^&*+=|?:<>/-]'
  Token_Punctuation = '[()\[\],.]'
  Token_Keyword = '(a(?:sm|uto)|break|c(?:ase|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtern)|for|goto|if|re(?:gister|stricted|turn)|s(?:izeof|t(?:atic|ruct)|witch)|typedef|union|(?:volat|wh)ile)\b'
  Token_Keyword_Type = '(bool|int|long|float|short|double|char|unsigned|signed|void)\b'
  Token_Keyword_Reserved = '(_(?:(?:(?:_)?)inline)|inline|naked|restrict|t(?:hread|ypename))\b'
  Token_Keyword_Reserved = '(__m(128i|128d|128|64))\b'
  Token_Keyword_Reserved = '__(as(?:m|sume)|based|cdecl|declspec|except|f(?:astcall|inally|orceinline)|i(?:dentifier|nt(?:16|32|64|8))|leave|noop|raise|stdcall|try|unaligned|w(?:64|char_t))\b'
  Token_Name_Builtin = '(true|false|NULL)\b'
  (Token_Name_Label,Token_Text,Token_Punctuation) = `([a-zA-Z_]\w*)(\s*)(:)[^:]`
  Token_Name = '[a-zA-Z_]\w*'
  Token_Punctuation = '[{}]'
  Token_Punctuation = ';' exit
end
